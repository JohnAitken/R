<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="John Aitken">

<title>pdf_scrape_log</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="pdf_scrape_process_files/libs/clipboard/clipboard.min.js"></script>
<script src="pdf_scrape_process_files/libs/quarto-html/quarto.js"></script>
<script src="pdf_scrape_process_files/libs/quarto-html/popper.min.js"></script>
<script src="pdf_scrape_process_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="pdf_scrape_process_files/libs/quarto-html/anchor.min.js"></script>
<link href="pdf_scrape_process_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="pdf_scrape_process_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="pdf_scrape_process_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="pdf_scrape_process_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="pdf_scrape_process_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">pdf_scrape_log</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>John Aitken </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="pdf-scraping-of-a-gag" class="level2">
<h2 class="anchored" data-anchor-id="pdf-scraping-of-a-gag">PDF Scraping of a GAG</h2>
<p>I used the Tesseract library in R to ocr scan the contents of a GAG as a starting process. (I used ChatGPT for a lot of it!).</p>
<p>OCR was required because the GAGs were not amenable to reading using the PDFTools package, which would have been a lot easier and with a cleaner output.</p>
<p>And though it is slow, this method would get me the raw data I could use to work out how to extract the pertinent information we need from the GAG to compare against other environment GAGs.</p>
</section>
<section id="ocr-code" class="level2">
<h2 class="anchored" data-anchor-id="ocr-code">OCR Code</h2>
<p>So I extract the data line by line and then add a couple of columns - namely the filename and page number - to a finished dataframe we can then work with. The overall code is something like this:</p>
<pre><code># ATTEMPT 5

start_time &lt;- Sys.time()

library(tesseract)
library(tidyverse)

# Set your working directory to the folder containing PDF files
pdf_folder &lt;- "C:/Users/JA/Documents/Git_Repositories/R/pdfScrapeDev"
setwd(pdf_folder)

# Tesseract read
eng &lt;- tesseract("eng")

# Get a list of all PDF files in the folder
pdf_files &lt;- list.files(pattern = "\\.pdf$", full.names = TRUE)

# Initialize a list to store results
all_results &lt;- list()

# Loop through each PDF file
for (pdf_file in pdf_files) {
  cat("Processing file:", pdf_file, "\n")
  
  # Perform OCR on the PDF file
  text &lt;- ocr(pdf_file, engine = eng)
  
  # Determine the number of pages in the PDF
  num_pages &lt;- length(strsplit(text, "\n")[[1]])
  
  # Loop through pages 2 to num_pages+1
  for (page_num in 2:(num_pages + 1)) {
    if (length(text) &gt;= page_num) {
      text_lines &lt;- strsplit(text, "\n")[[page_num]]
      
      if (length(text_lines) &gt; 0) {
        # Create a data frame with index, page, text_lines, and pdf_file columns
        result_df &lt;- data.frame(
          pdf_file = pdf_file,
          page = page_num - 1,
          text_lines = text_lines
        )
        all_results &lt;- c(all_results, list(result_df))
      }
    }
  }
}

# Combine the results into a single data frame
df &lt;- dplyr::bind_rows(all_results)

# Delete any PNGs in folder left over from the OCR
png_files &lt;- list.files(pattern = "\\.png$")
if (length(png_files) &gt; 0) {
  # Remove all files with a ".png" extension
  file.remove(png_files)
  cat("Deleted", length(png_files), "PNG files.\n")
} else {
  cat("No PNG files found in the working directory.\n")
}

# Print the elapsed time to process
end_time &lt;- Sys.time()
elapsed_time &lt;- end_time - start_time
cat("Elapsed time:", format(elapsed_time, units = "secs"), "\n")</code></pre>
<p>The filename used is temporary, as is the GAG itself, but we found a GAG that was funded in such a way that all the extra tables that might nt have appeared on some GAGs, appear on this one. I took this as being the base for initial checks.</p>
<p>The output is a dataframe assigned to variable <em>df</em>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>function (x, df1, df2, ncp, log = FALSE)  </code></pre>
</div>
</div>
<p>Note the datatype of the <strong>text_lines</strong> column is <em>chr</em>. By default, a column that contains a character string in it is converted to factors. But because Factors are really for categorical data, <em>chr</em> suits well for mixes of numeric and alphanumeric data like this.</p>
<div class="callout-important callout callout-style-simple no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>Just to note, the elapsed time for doing a list of 5 Mainstream GAGs on a shared drive is 11.5 mins, which is bad. Doing that on my local machine takes 2.5 mins, which while not fast, is something to note when we get to working on folders full of PDFs.</p>
</div>
</div>
</div>
<p>I saved the dataframe to a CSV file. It was important to approach this incrementally, as the text_lines data was incredibly varied, and there was a mix of text we wanted (such as the values) and text we did not, which meant each row would have to have it’s own actions applied to it.</p>
</section>
<section id="keep-or-do-not" class="level2">
<h2 class="anchored" data-anchor-id="keep-or-do-not">Keep or do not</h2>
<p>First job was to remove all the rows of junk data, so in the csv I added a column called ’<em>remove_tag’</em> as a boolean <em>TRUE</em> or <em>FALSE</em>, determined on whether I wanted to keep the line or not. CSV is just easier for me to do this in. Once done, I could re-import to a dataframe and use that TAG as a filter later on down the line. I have done this here with the file <strong>raw_extract1.csv</strong>, whch I will pull into the <strong>dfx</strong> variable to keep it from the initial df.</p>
<p>This is so we can have a baseline with what to do for each row. Identifying the rows later down the line would be a future me’s prob…</p>
<div class="cell">

</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>